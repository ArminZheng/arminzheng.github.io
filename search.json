[{"title":"Gallery","url":"/2021/08/18/Gallery/","content":"测试用\n","tags":["笔记"]},{"title":"Hello World","url":"/2020/06/08/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","tags":["note"]},{"title":"函数式编程","url":"/2020/08/08/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","content":"鲜明的特点\n函数是一等公民，地位与变量同一地位；\n\n只用表达式，不用语句；语句代表执行某种操作，没有返回值，比如I/O操作；从一开始就是为了处理运算（computation），不考虑I/O，实际情况是尽可能限制到最小，保持计算过程的单纯性；\n\n没有副作用；保持独立，所有功能就是返回一个新的值，没有其他行为，尤其修改外部变量；\n\n不修改状态；这意味着状态不能保存在变量中，函数式编程使用递归保存状态。缺点是运行速度比较慢；\n\n引用透明；不依赖外部变量，只依赖输入参数，任何时候参数相同，返回值总是相同的；利于观察和理解的行为；\n\n\n意义\n代码简洁，开发快速；\n接近自然语言，易于理解；\n不依赖，更方便的代码管理；\n易于并发编程（concurrency）互不干扰；\n代码的热升级；\n\n","tags":["编程"]},{"title":"互联网协议","url":"/2020/08/08/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE/","content":"总体思路\n网络接口层\n\n0、1电信号\n以太网协议\n帧 Frame（以太数据包）:\n标头head 18 B （头部14 + 尾部：冗余校验码FCS 4）Frame check sequence\n\n数据data 46 ~ 1500 B （数据很长就分多个帧）（总共64 ~ 1518 B）\n\n前同步码：用来使接收端的适配器在接收 MAC 帧时能够迅速调整时钟频率，使它和发送端的频率相同。前同步码为 7 个字节，1 和 0 交替。\n\n帧开始定界符：帧的起始符，为 1 个字节。前 6 位 1 和 0 交替，最后的两个连续的 1 表示告诉接收端适配器：“帧信息要来了，准备接收”。\n\n\n\nMAC地址：48位 = 6 B = 12个十六进制数表示（6对），前6个十六进制（3对）是厂家编号，后6个（3对）是该厂家的网卡流水号（用来定位网卡和数据包的路径）\nARP 协议：网卡知道网卡的MAC地址\n所查询主机的IP，在对方MAC地址一栏填的是 FF:FF:FF:FF，表示这是一个广播\n它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。\n\n\n\n\n网络层\n\n网络地址（子网络）\nIP 协议（32 位）\n子网掩码（ip AND 掩码 == 网络部分）\n\n\nIP 数据包\nHead: 20~60\nData: 65535 - Head\n标头和数据放进帧的数据里面（可以分多个帧）\n\n\n“网络层”的功能是建立”主机到主机”的通信。\n\n\n传输层\n\n端口：不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。\n\n“传输层”的功能，就是建立”端口到端口”的通信。\n\n只要确定主机和端口，我们就能实现程序之间的交流。主机+端口，叫做”套接字”（socket）。\n\nUDP协议\n\nUDP数据包，也是由”标头”和”数据”两部分组成。\n“标头”部分主要定义了发出端口和接收端口 8 字节Bit\n“数据”部分就是具体的内容。总长度不超过65535字节Bit\n\n\n\n以太数据包 头 + IP数据包 头 + UDP 数据包 头\n\n\nTCP协议\n\n有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。\nTCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。\n\n\n\n\n应用层\n\nTCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。\n\n\n\n用户角度\n以太网标头需要知道：\n对方的MAC地址\n对方的IP地址\n\n\n但不在同一子网，无法知道对方MAC地址，必须通过Gateway网关转发\n上网设置\n静态IP地址\n本机的IP地址　　* 子网掩码\n网关的IP地址\nDNS的IP地址\n\n\n\n\n动态IP地址\nDHCP协议（应用层协议）\n不知道对面的MAC地址：就设置对方MAC地址为广播地址（FF-FF-FF-FF-FF-FF）\n我方对方的IP地址都不知道：就设置我方：0.0.0.0；对方255.255.255.255\n双方端口：协议规定好了，我方：68，对方：67\n由于MAC地址是广播，每个都收到，但IP地址是0….、255….DHCP知道 ”这是发给我的“ ，其他计算机都丢弃。\nDHCP服务器读出数据，分配好IP，发回一个DHCP响应包\n结构为：以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。\n计算机收到响应包，就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等参数。\n\n\n\n\n\n\n\n\n实例：访问一个网站\nDNS协议：已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包，53 端口。网址会转换为IP地址，得到响应，我们就知道对方的IP地址。\n\n子网掩码，判断是否为一个网段，不为一个网段，就必须通过网关的转发，于是接收方MAC地址将是本机网关的MAC地址。\n\n应用层协议：HTTP协议。请求头请求体等，假定长度为4960字节，将会被嵌入到TCP数据包中。\n\nTCP协议：接收方默认端口为80端口，本机端口是一个随机生成的1024~65535之间的整数，假定为51755。加入一个TCP数据包 20字节，总大小+20，4980字节\n\nIP协议：TCP数据包嵌入IP数据包，会设置双方IP地址。IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。\n\n以太网协议：IP数据包嵌入以太数据包，需要设置MAC地址，设置本机MAC地址，接收方设置为网关192.168.1.1的MAC地址（通过ARP协议得到，也就是广播获得的MAC地址）\n\n服务端响应\n\n通过多个网关转发，网站服务器收到4个以太网数据包。\n根据IP标头的序号，将4个包拼起来，读取出完整的TCP数据包，读出请求，作出响应，再用TCP协议发回来。\n本机收到响应后，就可以将网页显示出来了，通信完成。\n\n\n\n\n\n\n三次握手\nSYN(synchronous建立连接) （标志位 1 bit）    最后一次握手SYN不为1是不消耗序号的 \nACK(acknowledgement 确认) \nPSH(push传送) \nFIN(finish结束) \nRST(reset重置) \nURG(urgent紧急)\n\n以上是标志位\n\n以下是序号和确认号\n\nSequence number (seq 序号) \nAcknowledge number (AN 确认号) 是对方的序号。如果占用己方序号和对方确认号都加一\nack确认报文段不占用序号，只有三种情况需要占用\n1、syn=1\n2、fin=1\n3、携带数据一个字节占用一个序号\n\n\n序号和确认号是相对的，seq表示上次发送的数据量，an代表上次接收的数据量（都是累加还算上初始值）\n\n\n\n\n","tags":["计算机网络"]}]